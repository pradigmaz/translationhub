# Generated by Django 5.2.5 on 2025-10-10 00:00

import logging
from django.db import migrations, transaction
from django.utils import timezone


logger = logging.getLogger(__name__)


def populate_team_lifecycle_data(apps, schema_editor):
    """
    Заполняет данные жизненного цикла для существующих команд:
    - Устанавливает статус ACTIVE для всех команд
    - Создает начальные записи в TeamStatusHistory
    - Устанавливает joined_at и is_active для участников
    """
    Team = apps.get_model('teams', 'Team')
    TeamMembership = apps.get_model('teams', 'TeamMembership')
    TeamStatusHistory = apps.get_model('teams', 'TeamStatusHistory')
    
    # Счетчики для статистики
    teams_updated = 0
    memberships_updated = 0
    history_records_created = 0
    errors = 0
    
    logger.info("Начинаем миграцию данных жизненного цикла команд")
    
    # Получаем все команды
    teams = Team.objects.all()
    total_teams = teams.count()
    
    if total_teams == 0:
        logger.info("Команды для обновления не найдены")
        return
    
    logger.info(f"Найдено команд для обработки: {total_teams}")
    
    # Обрабатываем каждую команду в отдельной транзакции
    for team in teams:
        try:
            with transaction.atomic():
                # 1. Устанавливаем статус ACTIVE если он не установлен
                if not team.status:
                    team.status = 'active'
                    team.save(update_fields=['status'])
                    teams_updated += 1
                    logger.debug(f"Установлен статус ACTIVE для команды: {team.name}")
                
                # 2. Создаем начальную запись в истории если её нет
                existing_history = TeamStatusHistory.objects.filter(team=team).exists()
                if not existing_history:
                    # Используем created_at команды или текущее время
                    creation_time = team.created_at if hasattr(team, 'created_at') and team.created_at else timezone.now()
                    
                    TeamStatusHistory.objects.create(
                        team=team,
                        changed_by=team.creator,
                        change_type='created',
                        old_status=None,
                        new_status='active',
                        reason='Начальная запись при миграции данных',
                        timestamp=creation_time
                    )
                    history_records_created += 1
                    logger.debug(f"Создана начальная запись в истории для команды: {team.name}")
                
                # 3. Обновляем участников команды
                memberships = TeamMembership.objects.filter(team=team)
                for membership in memberships:
                    updated_fields = []
                    
                    # Устанавливаем joined_at если не установлено
                    if not membership.joined_at:
                        # Используем created_at команды или текущее время
                        membership.joined_at = team.created_at if hasattr(team, 'created_at') and team.created_at else timezone.now()
                        updated_fields.append('joined_at')
                    
                    # Устанавливаем is_active=True если не установлено
                    if membership.is_active is None:
                        membership.is_active = True
                        updated_fields.append('is_active')
                    
                    if updated_fields:
                        membership.save(update_fields=updated_fields)
                        memberships_updated += 1
                        logger.debug(f"Обновлен участник {membership.user.username} в команде {team.name}")
        
        except Exception as e:
            errors += 1
            logger.error(f"Ошибка при обработке команды {team.name}: {str(e)}", exc_info=True)
            # Продолжаем обработку остальных команд
            continue
    
    # Логируем итоговую статистику
    logger.info(f"Миграция данных завершена:")
    logger.info(f"- Команд обновлено: {teams_updated}")
    logger.info(f"- Участников обновлено: {memberships_updated}")
    logger.info(f"- Записей истории создано: {history_records_created}")
    logger.info(f"- Ошибок: {errors}")
    
    if errors > 0:
        logger.warning(f"Миграция завершена с {errors} ошибками")
    else:
        logger.info("Миграция завершена успешно")


def reverse_populate_team_lifecycle_data(apps, schema_editor):
    """
    Обратная миграция - очищает данные жизненного цикла.
    ВНИМАНИЕ: Это действие может привести к потере данных!
    """
    Team = apps.get_model('teams', 'Team')
    TeamMembership = apps.get_model('teams', 'TeamMembership')
    TeamStatusHistory = apps.get_model('teams', 'TeamStatusHistory')
    
    logger.warning("Выполняется обратная миграция данных жизненного цикла команд")
    
    # Удаляем записи истории, созданные миграцией
    deleted_history = TeamStatusHistory.objects.filter(
        change_type='created',
        reason='Начальная запись при миграции данных'
    ).delete()
    
    logger.info(f"Удалено записей истории: {deleted_history[0] if deleted_history[0] else 0}")
    
    # Сбрасываем статус команд на значение по умолчанию
    teams_reset = Team.objects.update(status='active')
    logger.info(f"Сброшен статус для {teams_reset} команд")
    
    # Сбрасываем joined_at для участников (is_active оставляем True, так как поле NOT NULL)
    memberships_reset = TeamMembership.objects.update(joined_at=None)
    logger.info(f"Сброшены данные для {memberships_reset} участников")
    
    logger.warning("Обратная миграция завершена")


class Migration(migrations.Migration):

    dependencies = [
        ('teams', '0004_add_team_lifecycle_fields'),
    ]

    operations = [
        migrations.RunPython(
            populate_team_lifecycle_data,
            reverse_populate_team_lifecycle_data,
            hints={'teams': ['Team', 'TeamMembership', 'TeamStatusHistory']}
        ),
    ]